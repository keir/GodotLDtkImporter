extends Object

class LDtkTileset:
	var uid
	var name
	var gridSize
	var texture
	var tileset
	var path
	var createdTileIds
	var collisionShape
	
class LDtkLayer:
	var uid
	var gridSize
	var tileset_uid
	var auto_tileset_uid

# A simple logging system. Change log_level as desired.
var log_level = 'INF'
var log_levels = {'DBG': 0, 'INF': 1, 'WRN': 2, 'ERR': 3}
func log_msg(lvl, msg):
	if log_levels[lvl] >= log_levels[log_level]:
		print("LDtk importer [%s]: %s" % [lvl, msg])
func log_debug(msg):   log_msg('DBG', msg)
func log_info(msg):    log_msg('INF', msg)
func log_warning(msg): log_msg('WRN', msg)
func log_error(msg):   log_msg('ERR', msg)
	
func load_ldtk_file(ldtkFilePath):
	# Read the file contents.
	var ldtkFile = File.new()
	var err = ldtkFile.open(ldtkFilePath, File.READ)
	if err != OK:
		log_error("Couldn't open file: %s" % ldtkFilePath)
		return {"error": err}
	var ldtkFileContents = ldtkFile.get_as_text()
	ldtkFile.close()
	
	# Parse JSON.
	var parsedLDtk = JSON.parse(ldtkFileContents)
	if parsedLDtk.error != OK:
		log_error("Couldn't parse file: %s" % ldtkFilePath)
		return {"error": parsedLDtk.error}
		
	return {
		"error": OK, 
		"result": parsedLDtk.result, 
		"defs": parsedLDtk.result["defs"],
		"levels": parsedLDtk.result["levels"]
	}

func load_tilesets(ldtkDefsData, ldtkHomeDirectory, tilesetDirPath):
	var tilesetDict = {}
	var ldtkTilesets = ldtkDefsData["tilesets"]
	for tilesetData in ldtkTilesets:
		# Assume realtive path as this will be the most common case
		var texturePath = ldtkHomeDirectory.plus_file(tilesetData["relPath"])
		
		# Check for an absolute path. 
		# This should only happen if the user selected an image on a diffrent drive
		if tilesetData["relPath"].is_abs_path():
			texturePath = tilesetData["relPath"]
		
		var ldtkTileset = LDtkTileset.new()
		ldtkTileset.uid = tilesetData["uid"]
		ldtkTileset.name = tilesetData["identifier"]
		ldtkTileset.gridSize = tilesetData["tileGridSize"]
		ldtkTileset.texture = load(texturePath)
		ldtkTileset.path = tilesetDirPath.plus_file(tilesetData["identifier"] + ".tres")
		ldtkTileset.createdTileIds = {}
		ldtkTileset.tileset = TileSet.new()
		ldtkTileset.collisionShape = RectangleShape2D.new()
		ldtkTileset.collisionShape.set_extents(Vector2(ldtkTileset.gridSize / 2.0, ldtkTileset.gridSize / 2.0))
		tilesetDict[ldtkTileset.uid] = ldtkTileset
		
	return tilesetDict
	
func load_layer_defs(ldtkDefsData):
	var layerDict = {}
	var ldtkLayerDef = ldtkDefsData["layers"]
	for layer in ldtkLayerDef:
		var ldtkLayer = LDtkLayer.new()
		ldtkLayer.uid = layer["uid"]
		ldtkLayer.gridSize = layer["gridSize"]
		ldtkLayer.tileset_uid = layer["tilesetDefUid"]
		ldtkLayer.auto_tileset_uid = layer["autoTilesetDefUid"]
		
		layerDict[ldtkLayer.uid] = ldtkLayer
		
	return layerDict
	
func generate_level(level, layersDef, tilesets, outputDir, extension):
	# Always re-create the scene; never modify the existing ones. The
	# autogenerated levels should be considered read-only, since any
	# modifications in LDTK will trample over any manual edits.
	var rootNode = Node2D.new()
	rootNode.name = level["identifier"]
	log_debug("Generating level: %s" % rootNode.name)
	
	# Create entity layers root node.
	var entitiesRootNode = Node2D.new()
	entitiesRootNode.name = "Entities"
	rootNode.add_child(entitiesRootNode, true)
	entitiesRootNode.owner = rootNode
	
	# Create tile layers root node.
	var layerRootNode = Node2D.new()
	layerRootNode.name = "Layers"
	rootNode.add_child(layerRootNode, true)
	layerRootNode.owner = rootNode
	
	for layer in level["layerInstances"]:
		if layer["__type"] == "Entities":
			var entityLayer = Node2D.new()
			entityLayer.name = layer["__identifier"]
			entitiesRootNode.add_child(entityLayer, true)
			entityLayer.owner = rootNode
			entitiesRootNode.move_child(entityLayer, 0)

			# Create & place the entity; reverse stacking order of entities for Godot.
			for entityInstance in layer["entityInstances"]:
				var entity = _create_entity(entityInstance)
				if entity:
					entityLayer.add_child(entity, true)
					entity.owner = rootNode
					entityLayer.move_child(entity, 0)

		elif layer["__type"] in ["Tiles", "AutoLayer", "IntGrid"]:
			# Note: layerNode is a TileMap in this case.
			var layerNode = _create_layer(layer, layersDef, tilesets)
			if layerNode:
				layerRootNode.add_child(layerNode, true)
				layerNode.owner = rootNode
				layerRootNode.move_child(layerNode,0)
		else:
			log_error("Unknown layer; got '__type': '%s'" % layer["__type"])
		
	if layerRootNode.get_child_count() == 0 && entitiesRootNode.get_child_count() == 0:
		log_warning("No layers or entities loaded from file; is it empty?")
		return null

	var sceneFile = outputDir.plus_file(level["identifier"] + "." + extension)
	var scene = PackedScene.new()
	scene.pack(rootNode)
	ResourceSaver.save(sceneFile, scene)
	return sceneFile

var cachedScenes = {}
func load_scene(scenePath):
	if scenePath in cachedScenes:
		return cachedScenes[scenePath]
	var scene = ResourceLoader.load(scenePath)
	cachedScenes[scenePath] = scene
	return scene

# entity is the JSON entity object from LDtk.
func _create_entity(entity):
	# The maping from LDtk to Godot entity requires two pieces of information:
	#
	#  1. The node name to instantiate; found in the __identifier field.
	#  2. The scene the node is found in; found in the "scene" entity field.
	#
	# Use the LDtk "identifier" field determine the name.
	var entityIdentifier = entity["__identifier"]

	# Pull out the _Scene and _Node values, if present.
	var entityScenePath = null
	var entityNodeClass = null
	for field in entity["fieldInstances"]:
		if field["__identifier"] == "_Scene":
			entityScenePath = field["__value"]
		if field["__identifier"] == "_Node":
			entityNodeClass = field["__value"]

	# Load and instantiate the scene, if requested.
	var entitySceneInstance = null
	if entityScenePath != null:
		var entityScene = load_scene(entityScenePath)
		if entityScene == null:
			log_error("Ignoring entity '%s': couldn't load scene %s" % [entityIdentifier, entityScenePath])
			return null
		entitySceneInstance = entityScene.instance()
		# Don't try to recover entity on failure.
		if entitySceneInstance == null:
			log_error("Ignoring entity '%s': couldn't be instantiated from scene %s" % [entityIdentifier, entityScenePath])
			return null

	# Instantiate the node, if requested.
	var entityNodeInstance = null
	if entityNodeClass != null:
		log_debug("Entity '%s': using custom node class: %s" % [entityIdentifier, entityNodeClass])
		entityNodeInstance = ClassDB.instance(entityNodeClass)
		# Don't try to recover entity on failure.
		if entityNodeInstance == null:
			log_error("Ignoring entity '%s': couldn't instantiate class %s from scene %s" % [entityIdentifier, entityNodeClass, entityScenePath])
			return null

	# Got both _Scene and _Node? Nest the scene inside the node.
	if entitySceneInstance != null and entityNodeInstance != null:
		log_error("Entity '%s': using both _Node and _Scene together on the same node doesn't work at the moment" % entityIdentifier)
		# TODO: This doesn't work, and I'm not sure why.
		#entityNodeInstance.add_child(entitySceneInstance)
		# Just take the scene instance for now, since it's usually preferable.
		entityNodeInstance = entitySceneInstance
			
	# Didn't get _Scene or _Node? Default to a Node2D.
	if entityScenePath == null and entityNodeClass == null:
		log_warning("Entity '%s' has no _Scene or _Node field; defaulting to Node2D" % entityIdentifier)
		entityNodeInstance = Node2D.new()

	if entityNodeInstance == null:
		assert(entitySceneInstance)
		entityNodeInstance = entitySceneInstance

	assert(entityNodeInstance)

	# Field: Name
	#
	# Note: This can be overwritten with a custom field "name" below, enabling
	# setting the node names per instance. This just defaults to the entity
	# identifier.
	entityNodeInstance.set_name(entityIdentifier)

	# Field: Position
	if not entityNodeInstance.set("position", Vector2(entity["px"][0],entity["px"][1])):
		log_debug("No previous position field on node: '%s'" % entityIdentifier)
		
	# Field: Custom fields
	# LDtk supports custom fields for entities. Map those to Godot properties, and set them.
	for field in entity["fieldInstances"]:
		# Skip known fields.
		if field["__identifier"] in ["_Scene", "_Node"]:
			continue
			
		var fieldName = field["__identifier"]
		var fieldValue = field["__value"]
		var fieldType = field["__type"]

		# Skip null fields.
		if fieldValue == null:
			log_debug("Skipping null field: %s" % fieldName)
			continue
		
		log_debug("Setting %s[%s] = %s" % [entityIdentifier, fieldName, fieldValue])
		match fieldType:
			"Point":
				if typeof(fieldValue) == TYPE_ARRAY:
					var newArray = []
					for value in fieldValue:
						newArray.append(Vector2(value["cx"], value["cy"]))
					fieldValue = newArray
				else:
					fieldValue = Vector2(fieldValue["cx"], fieldValue["cy"])
			"Color":
				if typeof(fieldValue) == TYPE_ARRAY:
					var newArray = []
					for value in fieldValue:
						newArray.append(Color(value))
					fieldValue = newArray
				else:
					fieldValue = Color(fieldValue)
			"Enum":
				log_warning("Enums on entities are not properly supported; ignoring field: %s" % fieldName)
		
		if not entityNodeInstance.set(fieldName, fieldValue):
			log_debug("Field '%s' does not exist on node '%s'" % [fieldName, entityIdentifier])
	
	log_debug("Entity created: %s" % entityIdentifier)
	return entityNodeInstance
	
func _create_layer(layer, layersDef, tilesets):
	# Find the tiles to create for this layer.
	var tiles = layer["autoLayerTiles"]
	if len(tiles) <= 0:
		tiles = layer["gridTiles"]
	if len(tiles) <= 0:
		log_warning("No tile map found for layer: %s" % layer["__identifier"])
		return null

	# In tile units
	var layerWidth = layer["__cWid"]
	var layerHeight = layer["__cHei"]
	var layerGridSize = layer["__gridSize"]

	# Only create collision shapes for intgrid layers.
	var intGridTiles = []
	if layer["__type"] == "IntGrid":
		intGridTiles = layer["intGrid"]
		
	# Find the tileset for this layer.
	var tileset = null
	var layerDef = layersDef[layer["layerDefUid"]]
	if layerDef.auto_tileset_uid:
		tileset = tilesets[layerDef.auto_tileset_uid]
	elif layerDef.tileset_uid:
		tileset = tilesets[layerDef.tileset_uid]
	else:
		log_warning("No tile set found for layer: %s" % layer["__identifier"])
		return null

	# Create fresh tilemap.
	var tilemap = TileMap.new()
	tilemap.name = layer["__identifier"]
	tilemap.modulate.a = layer["__opacity"]
	tilemap.cell_size = Vector2(layerDef.gridSize, layerDef.gridSize)
	tilemap.tile_set = tileset.tileset

	# Create tiles; but don't create collisions for them yet.
	var tileCoordIdToTileId = {}
	for tile in tiles:
		var tilePos = Vector2(tile["src"][0], tile["src"][1])
		var region = Rect2(tilePos, tilemap.cell_size)
		var tileId = tile["t"]
		_create_tile(tileId, region, tileset)
		
		var worldPos = Vector2(tile["px"][0], tile["px"][1])
		var gridPos = tilemap.world_to_map(worldPos)
		var flip = int(tile["f"])
		var flipX = bool(flip & 1)
		var flipY = bool(flip & 2)
		
		tilemap.set_cellv(gridPos, tileId, flipX, flipY)

		# Update the coordId --> tileId map for collision use later.
		var tileCoordId = tile["px"][1] / layerGridSize * layerWidth + tile["px"][0] / layerGridSize
		tileCoordIdToTileId[tileCoordId] = tileId

	# Only create collision tiles for grid cells with integer values. This is
	# the common case, where autotile layers and intGrid layers are often
	# decorations.
	for tile in intGridTiles:
		_make_collision_tile(tileCoordIdToTileId[tile["coordId"]], tileset)
	
	return tilemap
	
func _make_collision_tile(tileId, tileset):
	# TODO: Test uneven grid size; e.g. 5x5
	tileset.tileset.tile_set_shape(tileId, 0, tileset.collisionShape)
	tileset.tileset.tile_set_shape_offset(tileId, 0, Vector2(tileset.gridSize / 2.0, tileset.gridSize / 2.0))

func _create_tile(tileId, region, tileset): # region, texture, tileset):
	# Note: The check below should instead be:
	#
	#   if not tileset.has_tile(tileId):
	#
	# However, Godot does not expose the TileSet::has_tile(tile_id) method from
	# C++. So to avoid re-generating an array of all the tiles for every
	# tileset for every node, keep a local cache of the tileIds that were
	# already created.
	#
	# TODO: Submit upstream Godot patch to expose a performant has_tile().
	if not tileId in tileset.createdTileIds:
		tileset.tileset.create_tile(tileId)
		tileset.createdTileIds[tileId] = true

	tileset.tileset.tile_set_tile_mode(tileId, TileSet.SINGLE_TILE)
	tileset.tileset.tile_set_texture(tileId, tileset.texture)
	tileset.tileset.tile_set_region(tileId, region)


# Godot gets cranky if there is no resource placed at expected save_path
# location in the filesystem, even if there are genfiles created. In the case
# of the LDtk importer, there isn't a "single" resource created, but rather a
# series of them; so the single save_path doesn't make sense. So make an empty
# scene at the expected save_pach (which is inside the res//.import/...
# directory) to satisfy Godot.
#
# TODO: Submit upstream Godot bug about:
#
#  (1) Docs do NOT explain the requirement for the save_file parameter.
#      Furthermore, the other arguments are barely documented. The required pre- and
#      post-conditions for the import() function are not explained precisely. And to
#      make the situation worse, it is not obvious where to look in the Godot source
#      code to figure this out.
#
#  (2) Lack of error checking around user defined functions. There should be a
#      useful error for obvious cases like the user failing to write out a file at
#      an expected path.
#
func _write_empty_scene(save_path, save_extension):
	var scene_file_path = save_path + "." + save_extension
	log_debug("Writing empty scene to satisfy Godot: %s" % scene_file_path)
	var scene = PackedScene.new()
	var root_node = Node.new()
	scene.pack(root_node)
	return ResourceSaver.save(scene_file_path, scene)


func _banner(message):
	log_info("=============== %s ===============" % message)
	

func run_import(source_file, save_path, save_extension, gen_files):
	_banner("BEGIN LDTK IMPORT")
	assert(_write_empty_scene(save_path, save_extension) == OK)

	# Must match get_save_extension() in LDtkImportPlugin.gd
	# Load the two key parts of the level: the definitions and levels.
	log_info("Loading file: %s" % source_file)
	var ldtkFile = load_ldtk_file(source_file)
	if ldtkFile.error != OK:
		_banner("END LDTK IMPORT")
		return ldtkFile.error

	save_path = source_file.get_basename()
	var tilesetPath = save_path.plus_file("tilesets")
	
	var directory = Directory.new()
	if !directory.dir_exists(tilesetPath):
		log_debug("Creating directory: %s" % tilesetPath)
		var error = directory.make_dir_recursive(tilesetPath)
		if error != OK:
			_banner("END LDTK IMPORT")
			return error
		
	log_debug("Loading layer definitions")
	var layerDefs = load_layer_defs(ldtkFile.defs)
	log_debug("Loading tileset definitions")
	var tilesets = load_tilesets(ldtkFile.defs, source_file.get_base_dir(), tilesetPath)
	
	# Note: The tilesets are incrementally built during the level creation
	# process, adding only tiles from the tileset that are used in a tilemap.
	# This is why saving the tileset is deferred until the end of the import.
	for level in ldtkFile.levels:
		var scenePath = generate_level(level, layerDefs, tilesets, save_path, save_extension)
		if scenePath:
			log_info("Wrote level: %s" % scenePath)
			gen_files.append(scenePath)
			
	for tileset in tilesets.values():
		if ResourceSaver.save(tileset.path, tileset.tileset) == OK:
			log_info("Wrote tileset: %s" % tileset.path)
			gen_files.append(tileset.path)
		else:
			log_error("Error saving: %s" % tileset.path)
	_banner("END LDTK IMPORT")
	return OK
